LEP 语言 1.0.01 说明文档

————————————————————————————————————————————————————————————————————————————————————————

1、概述
	LEP 语言全称 LEP Encourages Programming 语言，是基于 C# 的一种划时代的脚本语言。它吸收多种语言的长处，语法简洁，结构严谨，容易掌握，是理想的脚本专用语言。
	符合该说明文档的 LEP 解释器（版本 1.0）已经编写完成，暂时仅供内部测试使用。未来 LEP 语言及解释器还会进一步完善和发展（详细内容见未来发展）。
	我们欢迎其他开发者加入编写 LEP 语言及解释器的队伍中，帮助改进 LEP 语言和解释器中不足之处，消除 LEP 解释器中的 BUG，进一步发展 LEP 语言。

————————————————————————————————————————————————————————————————————————————————————————

2、类型
	I、概述
		LEP 语言内置两种基本类型：整数及字符串。LEP 语言内置有相互转换基本类型的函数。
		整数的范围介于 -2^31 和 2^31-1 之间。字符串原则上可以无限长，但受内存限制，最长可支持约 20 亿个 ASCII 字符（2 GB）。
		除基本类型外，LEP 语言还支持元组——一些表达式的集合。


	II、通用类型
		通用类型亦属于一种类型，是其他所有类型的父类型，可看作是所有类型的综合。
		通用类型主要用于原生函数。调用原生函数时可将任意类型的实参值传入至通用类型的形参。

————————————————————————————————————————————————————————————————————————————————————————

3、变量及常量
	I、变量
		A、概述
			变量是一种可变值，赋值后具有特定类型。变量须声明后方能访问，声明方式包括赋值、元组匹配及函数形参声明。
			LEP 语言采用动态类型，因而可以将任何类型的数据赋予一个变量，声明变量时也无需指定类型（随时定义，随时使用）。
			可以认为未赋值变量属于通用类型，因而能够在部分原生函数中使用未赋值变量。

		B、变量名
			变量名是变量的标识符，只有通过变量名才能访问变量。一个变量的变量名在声明时即已确定，无法再更改。
			变量名只能由拉丁字母（大小写均可）、数字及下划线（"_"）组成，且第一个字符必须是拉丁字母或下划线（"_"）。

		C、作用域
			变量的作用域即变量的有效访问范围。变量只能在其所属作用域内访问，在作用域外无法访问。
			在语句块、关卡、函数中声明的变量，其作用域即是其所属的语句块、关卡或函数；直接在脚本最外层声明的变量则以整个脚本为作用域。

		D、全局变量、局部变量、外部变量
			以整个脚本为作用域的变量即为全局变量；与此相对，作用域仅限于一段脚本的变量为局部变量。一般情况下，访问变量时优先访问局部变量，且作用域靠内的优先，以此类推。
			外部变量介于全局变量和局部变量之间，是具有特定变量名的变量中作用域最靠外的变量，可以是全局变量或局部变量。
			注意：可以访问外部变量，但不能声明外部变量，因为解释器无法确定其作用域。

		E、作用域符
			作用域符用于访问指定作用域的变量，或在声明变量时指定作用域。作用域符包括局部变量符（"@"）、全局变量符（"$"），以及外部变量符（"~"）三种：
				局部变量符（"@"）：指定访问或声明（如果未声明）局部变量；
				全局变量符（"$"）：指定访问或声明（如果未声明）全局变量；
				外部变量符（"~"）：指定访问外部变量。
			注意：除非特殊需要（如引用其他脚本），请尽量避免使用作用域符（尤其是外部变量符）。对嵌套作用域中不同的变量赋予不同的变量名是一种良好的编程习惯。


	II、常量
		LEP 暂不支持定义常量，但可以使用常量字面量。
		整数字面量即一般的整数，字符串字面量为由一对双引号括起的、由 ASCII 字符组成的字串（转义字符表见附录）。

————————————————————————————————————————————————————————————————————————————————————————

4、运算符
	I、概述
		A、分类
			LEP 语言中运算符包括指示符、前缀符及算术符。（详细运算符表见附录）

		B、优先级
			运算符的优先级决定了表达式计算的顺序和方式，优先级的值越小优先级越高。优先级高的运算符先进行运算。
			指示符的优先级相等，且高于其他所有运算符。前缀符的优先级亦相等，仅次于指示符，高于算术符。算术符依照使用习惯有不同的优先级。（详细运算符优先级表见附录运算符表）

		C、结合方向
			运算符的结合方向决定了表达式计算的方向，多个优先级相等的运算符顺序运算时，依照结合方向依次计算。
			一般情况下，优先级相等的运算符，其结合方向亦相同。（详细运算符结合方向表见附录运算符表）


	II、指示符
		指示符（或合并符）位于一个或多个表达式两侧，将表达式组合起来形成单个值。
		指示符包括单表达式符和多表达式符。单表达式符中最多只能有一个表达式，多表达式符中可以有多个表达式（称为元素），通过元素分隔符（":"）分隔；指示符中均可为空。
	
	
	III、前缀符
		前缀符位于表达式前，执行有关表达式的计算及操作。
		前缀符包括自变符和值变符。自变符后只能跟可赋值变量，计算时会改变变量的值；值变符后可跟任意表达式，只计算表达式的值而后改变计算值。


	VI、算术符
		算术符位于两个表达式之间，执行有关两个表达式的计算及操作。所有算术符都支持整数间运算。
		算术符包括求余在内的四则运算算术符，逻辑与、逻辑或运算符及赋值类算术符，还有关系算术符。
		在算术符中加法类算术符（"+" 和 "+="）支持字符串及元组连接，赋值类算术符（"=" 和 "+="、"-=" 等） 支持变量赋值及元组匹配，判等类算术符（"==" 和 "!="）支持变量或常量比较。


	V、语法符
		就严格定义而言，语法符不属于运算符，为赋予其严谨的定义，特在此说明。
		语法符类似于其他语言中的保留字，是构成特殊语法的必要成分，但与其他语言略有不同，语法符均为符号，以增强脚本的通用性。

————————————————————————————————————————————————————————————————————————————————————————

5、语句及语句块
	I、语句
		语句是脚本的基本单位，虽然这并不意味着语句不能包含其他语句甚至更大的脚本单位（例如语句块）。解释器一次执行一个语句。
		语句可以是表达式、流程语句或语句块，也可以为空，因而可以将语句块看作是一条语句。（接下来的部分中，若无附加说明，语句同时包括语句块）
		语句间通过语句分隔符（","）或回车分隔，不需要以分号（";"）结尾（区别于 C 风格语言）。
		若语句不为空，语句返回表达式或语句块的值。


	II、语句块
		语句块是一系列语句的集合。可以在脚本的任何部分插入语句块。语句块也可以嵌套。
		语句块以语句块起始符（"->"）起始，中间包括若干语句（可以为空），最后以语句块结束符（终结符（"."）或连续符（";")）结束。
		语句块结束符决定了一些特定语句（如关卡列表）的执行方式，其中终结符（"."）结尾的语句块是终结性的，连续符（";")结尾的语句块是连续性的。
		一般情况下，若语句块中有非空语句，语句块返回语句块中最后一个非空语句的值。


	III、注释
		注释可以帮助人们理解脚本。注释与语句相近，但不属于语句，可以在脚本中的任何语句后出现。
		注释以注释起始符（"//"）起始，后跟一系列字符，即注释内容。在一行中若出现注释起始符（"//"），则其后字符均为注释直到行末。LEP 语言暂不支持多行注释，但可在多行中插入注释。
		解释器执行脚本时会忽略注释，因而注释支持 UNICODE 字符，使得人们可以用熟悉的语言编写注释。

————————————————————————————————————————————————————————————————————————————————————————

6、关卡及关卡列表
	I、关卡
		关卡用于进行判断执行，由一个表达式及一个语句块组成，只用于流程控制语句中。
		当脚本执行至关卡时，会先计算表达式的值，若为真（不为 0 或空字符串），则执行语句块并返回语句块的值，否则直接返回 0 值。
		可以将表达式替换为恒成立符（"*"），此时关卡默认表达式为真。恒成立符（"*"）可用于实现其他语言中的 else 功能
		注意：关卡（关卡列表）不能单独使用。


	II、关卡列表
		关卡列表提供多分支判断，由一系列关卡组成。与单个关卡相同，关卡列表亦只用于流程控制语句中。
		关卡列表以关卡列表起始符（":"）起始，后接一系列关卡，最后以终结符（"."）结束。
		执行关卡列表时，将依次执行各关卡。当某关卡表达式为真，关卡语句块执行完毕时，若语句块以终结符（"."）结束，关卡列表直接退出，否则继续执行下一个关卡（如果有）。
		若所有关卡表达式都不为真，关卡列表返回 0 值，否则返回最后执行的语句块的值。

————————————————————————————————————————————————————————————————————————————————————————

7、流程控制语句
	I、判断控制语句
		A、判断语句
			判断语句类似于其他语言中的 if 语句，用于进行判断分支。其主体是一个关卡列表，因而可以认为判断语句是关卡列表的具体表现形式。
			判断语句以判断起始符（"?"）起始，紧跟一个关卡列表（须有若干个空格分开，不能换行回车）。判断语句不需要以终结符（"."）结束。
			判断语句的返回值即是关卡列表的返回值。

		B、枚举判断语句
			枚举判断语句可以实现其他语言中的 case（switch） 功能，用于对一个特定表达式的值进行多分支枚举判断。
			与判断语句类似，枚举判断语句以判断起始符（"?"）起始，然后接枚举判断标识符（"="）(用若干个空格分开，不能换行回车）和一个待判断表达式，再跟一个关卡列表。
			执行枚举判断语句时，各个关卡比较的是关卡表达式与待判断表达式的值是否相等；若关卡表达式为恒成立符（"*"），则无论待判断表达式值为何，关卡一定会执行关卡语句块。


	II、循环控制语句
		A、循环语句
			循环语句类似于其他语言中的 while 语句，用于实现循环结构。LEP 暂不支持 do while 及 for 类语句。
			循环语句以循环起始符（"*"）起始，后跟一个关卡。与判断语句相同，循环语句无需以终结符（"."）结束。
			当且仅当关卡表达式不为真时，循环结束。循环语句返回最后一次完整执行的关卡语句块的值（若一次都没有，返回 0 值）。

		B、跳出语句及跳回语句
			跳出语句（"!"）类似于其他语言中的 break 语句，是一个单独的语句，用于跳出循环语句。跳出语句（"!"）不会改变循环语句的返回值。
			跳回语句（":!"）类似于其他语言中的 continue 语句，亦是单独的语句，用于结束本次循环，重新执行关卡。
			注意：跳出语句、跳回语句只能在循环语句中使用，在脚本其他地方使用会引发错误。

————————————————————————————————————————————————————————————————————————————————————————

8、元组
	I、概述
		元组是一些表达式的集合，对表达式值的类型没有特殊要求。元组可以将任意多个数据绑定成为一个量，用于传递参数或返回值等操作。
		元组通过显式元组声明符（"{}"）内包含若干个元素来表示，称为显式元组（相对于元组类型变量）。


	II、元组运算
		A、赋值运算
			可以像其他基本量一样将一个元组赋予一个变量，该变量即为元组类型。可以像使用显式元组一样使用元组类型变量。（接下来的部分中，若无附加说明，元组同时包括元组类型变量）

		B、连接运算
			可以通过加法类算术符（"+" 和 "+="）将一个元组和一个表达式或另一个元组相加：
				元组 + 表达式：将表达式添加至元组的末尾，组成一个新的元组；
				表达式 + 元组：将表达式添加至元组的开头，组成一个新的元组；
				元组 + 元组：将后一个元组中的所有元素按原顺序添加至前一个元组的末尾，组成一个新的元组。
			注意：加法赋值符（"+="）不支持表达式 + 元组的形式。

		C、比较运算
			元组间可通过判等类算术符（"==" 和 "!="）进行比较，当且仅当两个元组元素个数相同，且对应元素相等时，两个元组相等。
			注意：元组间不支持大小比较。


	III、元组匹配
		A、概述
			赋值类算术符（"=" 和 "+="、"-=" 等）可以将两个元素个数相同的元组连接起来，此时进行的是元组匹配操作。元组匹配可用于将元组中的元素提取至独立的变量中。
			元组匹配要求赋值运算符左侧元组中的元素全部是可赋值变量（可以未声明），元组也不能是变量，对右侧元组没有特别要求。右侧元组也可以是一个值为符合要求的元组类型的表达式。
			元组匹配时，左侧元组中的变量将会被赋予右侧元组中对应的元素；如果包含附加操作（如 "+="），将会先执行对应的操作。

		B、匿名元素
			匿名元素可以减少匹配所需的实际变量数目，从而从元组中提取特定的元素。匿名元素并不是变量，而仅仅是一个占位元素。
			匿名元素通过匿名符（"_"）表示。一个匿名符号即是一个匿名元素，同样需要通过元素分隔符（":"）隔开。
			元组匹配时，匿名元素将会被忽略，同时也不会计算右侧元组中对应的元素。
			注意：匿名符（"_"）只能应用于元组匹配及函数定义中，其他时候匿名符（"_"）仅作为独立的变量名使用。

————————————————————————————————————————————————————————————————————————————————————————

9、函数
	I、概述
		虽然 LEP 语言属于脚本语言，不需要主函数（main 函数），但 LEP 语言中仍有函数的概念。
		函数（或子程序）是一类特殊的脚本单位，用于执行特定的功能，可以传入参数，亦有返回值。
		函数需要定义后方能调用（原生函数除外），且能多次调用、嵌套调用，甚至递归调用。


	II、定义函数
		A、概述
			函数需要定义以说明其功能及参数，供后续脚本使用——函数只有定义后才能调用。函数只能在脚本最外层定义，不支持在语句块内定义函数。
			函数定义由函数定义符（"#"）起始，后接函数名及一个由参数名组成的元组（形参元组），最后跟一个语句块，称为函数体。
			函数名的要求同变量名。在某种程度上，可以将函数名看作是一种特殊的变量名。
			执行函数定义时，会在全局环境中添加一个函数定义对象，供函数调用时访问。函数定义的值即函数名。

		B、形式参数及形参元组
			形式参数（形参）是函数执行时函数体访问的变量，其作用域仅限于整个函数体。在函数体中，可以像使用局部变量一样使用形参。
			函数定义中的形参元组定义了函数的形参。形参列表中每一个元素都必须是变量名，即形参名。函数体访问形参时使用形参名。
			为了方便使用表达式转义参数调用函数，在形参元组中可以使用匿名变量，称为匿名参数。匿名参数仍然属于形参，但不能也不会被访问，传入参数时亦会忽略对应的实参。


	III、调用函数
		A、概述
			函数一经定义即可被调用。只有在调用函数时，才会在传入参数后执行函数体，完成特定的功能。
			调用函数时，以欲调用的函数名起始，后接调用函数所需的参数（实际参数或实参）组成的元组，称为实参元组。
			实参元组的元素个数必须与形参元组相等，若形参元组为空亦可以为空，但对具体的元素（实参）没有要求。可使用的实参元组形式包括显式元组参数和表达式转义参数。
			参数传入时每个实参的值会赋予对应的形参，相当于进行了一次元组匹配。参数传入完毕后，函数即开始利用形参执行函数体。
			函数调用完毕时，会返回函数体中最后执行的语句的值，一般是函数体中最后一个语句的值。

		B、显式元组参数
			最基本的函数调用方式是使用显式元组参数。调用函数时，须在函数名后紧接一个实参元组，否则解释器将不会将其识别为函数调用。

		C、表达式转义参数
			由于实参元组本质是元组，因而可以用值为元组类型的表达式调用函数。此时必须进行表达式转义，以便解释器识别。
			表达式转义时须将表达式放入参数转义符（"()"，属于语法符而非运算符）中，此时解释器会将表达式的值展开为显式元组以传入参数调用函数。
			只有值为元组类型的表达式才能够进行转义操作，试图对其它表达式进行表达式转义会引发错误。对表达式值的要求同显式元组。

		D、实参与形参的关系
			实参传入函数的是实参的值，此值将赋予对应的形参，即其他语言中的值传递。在函数中改变形参的值，不会影响到对应的实参的值。
			实际上，由于形参的作用域仅限于函数体，因而即使形参与实参有相同的变量名，函数体调用形参时也不会访问到实参。


	IV、原生函数
		原生函数内建于 LEP 解释器中，提供了仅通过 LEP 语言无法实现或比较复杂的功能，同时提高脚本的运行效率。
		原生函数不需要定义即可调用，调用方式与普通函数一致，但对参数有类型的要求，不匹配的类型可能会引发错误。
		（详细原生函数表见附录）

————————————————————————————————————————————————————————————————————————————————————————

X、未来发展
	I、新功能
		我们计划继续向 LEP 语言添加新的功能，包括：
			数组和列表（一种递归定义的、类似于链表的数据结构）；
			自定义数据类型（结构体或类）；
			函数中的引用传递；
			更多原生函数；
			* 脚本引用（库函数）；
			* 浮点类型；
			* 静态类型和类型检查；
			……
		这些新功能将会在 LEP 的后续版本中推出，敬请期待。
		（* 号表示远期计划）


	II、优化
		在发展新功能的同时，我们会进一步对已有的 LEP 解释器进行优化，包括：
			优化变量读写方法；
			进一步减少运行脚本时的内存占用；
			* 开发 LEP 虚拟机；
		这些优化将会在 LEP 的后续版本中推出，敬请期待。
		（* 号表示远期计划）


	III、脚本本地化
		在下一个版本的 LEP 语言中，最大的亮点将会是脚本本地化。我们正不断完善该功能，预计下一个版本即可推出。
		脚本本地化允许人们利用特定语言的翻译文件，用熟悉的书面语言编写脚本。解释器将会根据翻译文件将本地化的单词翻译成对应的语法符，从而使脚本顺利执行。
		可以自定义翻译文件，例如可以利用一份克林贡语的翻译文件，帮助《星际迷航》中的克林贡人编写他们熟悉的 LEP 脚本。（呵呵）
		未来推出的脚本翻译器更支持将基于一份翻译文件编写的 LEP 脚本翻译成基于另一份翻译文件的 LEP 脚本，敬请期待！

————————————————————————————————————————————————————————————————————————————————————————

P、附录
	I、转义字符表
		————————
		字符  含义
		————————
		"\n"  换行
		"\\"  反斜杠字符
		"\""  双引号
		————————


	II、运算符表
		——————————————————————————————
		类别                优先级  结合方向  运算符  名称
		——————————————————————————————
		指示符              1       自左至右  "()"    圆括号符
		                                      "{}"    显式元组声明符
		——————————————————————————————
		前缀符              2       自右至左  "++"    自增符
		                                      "--"    自减符
											  "+"     正号符
											  "-"     负号符
											  "!"     逻辑非符
		——————————————————————————————
		高级四则运算算术符  3       自左至右  "*"     乘法符
		                                      "/"     除法符
											  "%"     求余符
		——————————————————————————————
		初级四则运算算术符  4       自左至右  "+"     加法符
		                                      "-"     减法符
		——————————————————————————————
		大小关系算术符      5       自左至右  "<"     小于符
		                                      "<="    不大于符
											  ">"     大于符
											  ">="    不小于符
		——————————————————————————————
		判等类算术符        6       自左至右  "=="    等于符
		                                      "!="    不等于符
		——————————————————————————————
		逻辑与算术符        7       自左至右  "&&"    逻辑与符
		——————————————————————————————
		逻辑或算术符        8       自左至右  "||"    逻辑或符
		——————————————————————————————
		赋值类算术符        9       自右至左  "="     赋值符
		                                      "+="    加法赋值符
											  "-="    减法赋值符
											  "*="    乘法赋值符
											  "/="    除法赋值符
											  "%="    求余赋值符
											  "&&="   逻辑与赋值符
											  "||="   逻辑或赋值符
		——————————————————————————————


	III、原生函数表
		—————————————————————————————————————————————————————————
		函数名{参数类型}          返回值                    说明
		—————————————————————————————————————————————————————————
		write{通用}               0 值                      将参数的字符串形式输出至输出流。
		write_line{通用}          0 值                      将参数的字符串形式输出至输出流并换行回车。
		read{}                    读取的字符串              从输入流读取一行字符串。
		length{通用}              参数的长度（若有定义）    尝试获取参数的长度，可能会引发错误。
		to_string{通用}           参数的字符串形式          将参数转换为字符串类型值。
		to_int{通用}              参数的整数形式（若存在）  尝试将参数转换为整数类型值，可能会引发错误。
		time{}                    脚本执行的时间            获取解释器从开始执行脚本至现在经过的毫秒数。
		get_element{元组 : 整数}  指定位置的元素            尝试获取元组从开头计指定位置的元素，可能会引发错误。
		string_to_tuple{字符串}   字符串的元组形式          获取由字符串中各个字符按原顺序组成的元组。
		tuple_to_string{元组}     字符元组的字符串形式      尝试获取由元组中各个元素按原顺序组成的字符串，可能会引发错误。
		—————————————————————————————————————————————————————————

————————————————————————————————————————————————————————————————————————————————————————

LEP 语言开发小组